<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>SM.maps API documentation</title>
<meta name="description" content="The file has been build for creating beautiful maps!" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>SM.maps</code></h1>
</header>
<section id="section-intro">
<p>The file has been build for creating beautiful maps!</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# ======================================================================
# Created by : Mohit Anand
# Created on : On Sat Jan 16 2021 at 17:23:27
# ======================================================================
# __author__ = Mohit Anand
# __copyright__ = Copyright (c) 2021, Mohit Anand, Soil Moisture Project
# __credits__ = [Mohit Anand, Timo Houben]
# __license__ = MIT
# __version__ = 0.0.1
# __maintainer__ = Mohit Anand
# __email__ = mohit.anand@ufz.de
# __status__ = development
# ======================================================================
&#39;&#39;&#39; The file has been build for creating beautiful maps! &#39;&#39;&#39;
#

import os
from SM.io import read_raster, load_model, read_data
from SM.process import preprocess_raster, preprocess_raster_spatiotempmodel, raster_select_features, create_gdf_from_df
from SM.cfg import Project
from SM.training import SpatioTempModel

import pandas as pd

import matplotlib.pylab as plt
import matplotlib as mpl
import geopandas as gpd
import fnmatch
from pathlib import Path

class SpatialMap(object):
    def __init__(self, name, method, date, csv_file=None, plot_sensor_locs=True):

        self.name = name
        self.method = method
        self.uid = self.name + &#39;_&#39; +self.method 
        self.csv_file = csv_file
        self.date = date
        self.save_models_path = os.path.join(Project.models_path, self.name, 
                                             self.method)
        self.save_figures_path = os.path.join(Project.figures_path, self.name, 
                                              self.method)
        self.save_results_path = os.path.join(Project.figures_path)
        self.pred_gdf = None
        self.plot_sensor_locs = plot_sensor_locs

        Path(self.save_models_path).mkdir(parents=True, exist_ok=True)
        Path(self.save_figures_path).mkdir(parents=True, exist_ok=True)

        if self.csv_file is not None:
            print(&#34;The specified csv file will be taken for map creation.&#34;)
            self._create_gdf_from_csv()
        else:
            if Project.project_type == &#34;SpatioTempModel&#34;:
                self._predict_spatiotempmodel()
            else:
                self._predict()

        if self.plot_sensor_locs == True:
            try:
                self.daily_gdf = read_data()
            except FileNotFoundError:
                self.plot_sensor_locs = False
                print(&#34;Found no files with sensor locations.&#34;)

                
    def plot_maps(self, grid = True):
        &#34;&#34;&#34;Plot predicted raster data as maps and save as PNG.
        
        Parameter
        ---------
        grid : boolean, Default: True
            Set to True to plot the raster grid lines.
        &#34;&#34;&#34;
        
        # to plot sensor locatoins, load training_test data
        if self.plot_sensor_locs == True:

            daily_gdf = self.daily_gdf
            
            if not isinstance(daily_gdf, gpd.GeoDataFrame):
                daily_gdf = create_gdf_from_df(
                        daily_gdf, x=&#34;UTMWGS84_E[m]&#34;, y=&#34;UTMWGS84_N[m]&#34;)              
        
            if &#34;Date&#34; in daily_gdf.columns:
                try:
                    # if model is of class SpatioTempModel
                    daily_gdf = daily_gdf[daily_gdf[&#39;Date&#39;] == self.date]
                except: 
                    # if model is of class TrainDailyModel
                    daily_gdf = daily_gdf[daily_gdf[&#39;Date&#39;]==pd.to_datetime(self.date)]
        
        # load predicted raster data
        pred_gdf = self.pred_gdf
        if not isinstance(pred_gdf, gpd.GeoDataFrame):
            pred_gdf = create_gdf_from_df(pred_gdf)
        
        # check depth levels to create plot grid
        depth_list = pred_gdf[&#39;z&#39;].unique()
        n_depth = len(depth_list)

        # create plot grid and set color scheme
        fig, axes = plt.subplots(1, n_depth, figsize=(3*n_depth,6), sharey = True, sharex = True)
        #cmap = &#39;cviridis_r&#39;
        cmap = mpl.cm.get_cmap(&#39;cividis&#39;)
        cmap = cmap.reversed()
        norm = mpl.colors.Normalize(vmin = 0.1, vmax = 0.35)
        cmap.set_under(&#34;white&#34;)
        cmap.set_over(&#34;black&#34;)
        fmt = lambda x, pos: &#39;{:.0f}&#39;.format(x)

        # plot depth specific maps
        for i in range(n_depth):
    
            gdf_d = pred_gdf[pred_gdf[&#39;z&#39;]==depth_list[i]]
            
            gdf_d_plot = gdf_d.plot(ax=axes[i], column = &#39;pred&#39;, cmap = cmap, norm = norm)
            if self.plot_sensor_locs == True:
                daily_gdf_d = daily_gdf[daily_gdf[&#39;Depth_m&#39;] == depth_list[i]]
                daily_gdf_d.plot(ax=axes[i], column = &#39;Soil_moisture&#39;, cmap = cmap, norm = norm, edgecolor = &#39;k&#39;)
    
            axes[i].yaxis.set_major_formatter(mpl.ticker.FuncFormatter(fmt))
            axes[i].xaxis.set_major_formatter(mpl.ticker.FuncFormatter(fmt))
            axes[i].set_title(&#34;Depth [m]: &#34; + str(depth_list[i]), pad=20)
            if grid == True:
                axes[i].grid(color = &#39;grey&#39;, linestyle = &#39;--&#39;)
            collection = gdf_d_plot.collections[0]
        
        cbar = plt.colorbar(collection, ax=axes[-1], extend=&#39;both&#39;)
        cbar.ax.set_ylabel(&#39;Soil moisture [-]&#39;, fontsize = 14)
        
        # save maps as png
        f_path = os.path.join(self.save_figures_path, self.uid+&#39;_&#39;+self.date+&#39;_3d.png&#39;)
        plt.savefig(f_path)

        
    def _find_date_model_fname(self, date, model_path):
        
        list_files = os.listdir(model_path)

        file_name = None

        for each_file in list_files:
            if fnmatch.fnmatch(each_file, &#39;*_&#39;+date+&#39;*_model.sav&#39;):
                file_name = each_file.split(&#39;.&#39;)[0][:-6]

        if file_name == None:
            raise FileNotFoundError(&#34;There is no saved model with the specified name. \nTrain a model first or specify a csv file.&#34;)
        date = file_name.split(&#39;_&#39;)[2]

        return date, file_name
    

    def _predict(self):

        raster_data = read_raster()
        raster_data = raster_data[raster_data[&#39;mask&#39;]==False]
        processed_raster_data = preprocess_raster(raster_data)

        date, fname =self._find_date_model_fname(self.date, self.save_models_path)
        
        fpath = os.path.join(self.save_models_path, fname)
        
        model, scaler = load_model(fpath)
        
        data_scaled = scaler.transform(processed_raster_data.values)

        sm_pred = model.predict(data_scaled)

        raster_data[&#39;pred&#39;] = sm_pred 

        raster_data= raster_data.rename(columns = {&#39;z&#39;:&#39;Depth_m&#39;})
       
        self.pred_gdf = raster_data
        #self.date = date


        #return self.date, self.pred_gdf
        return self.pred_gdf
    
    
    def _predict_spatiotempmodel(self):
        &#34;&#34;&#34;Predict a map for a specific time stamp for a model of class 
        SpatioTempModel.
        
        Returns
        -------
        pandas.DataFrame
            Spatial map, columns (&#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;mask&#34;, &#34;pred&#34;).
        &#34;&#34;&#34;
        # load and preprocess raster data
        raster_data = read_raster()
        raster_data = raster_data[raster_data[&#39;mask&#39;]==False]
        processed_raster_data = preprocess_raster_spatiotempmodel(raster_data)
        feature_selected_raster_data = raster_select_features(
                                            processed_raster_data, self.date)
        # load regression model
        fpath = os.path.join(self.save_models_path, self.uid)
        model, scaler = load_model(fpath)
        
        # scale, predict
        data_scaled = scaler.transform(feature_selected_raster_data.values)
        sm_pred = model.predict(data_scaled)
        
        # output 
        pred_raster = processed_raster_data[[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;mask&#39;]]
        pred_raster = pred_raster.assign(pred = sm_pred) 
        self.pred_gdf = pred_raster
        
        # self.pred_gdf should look like this
        #            x           y     z     mask      pred
        #0      641952.55  5724795.24  0.05  False  0.229296
        return self.pred_gdf


    def _create_gdf_from_csv(self):

        df = pd.read_csv(self.csv_file)
        df = df[df[&#39;mask&#39;]==False]

        self.pred_gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.x, df.y))
        
        return self.pred_gdf
    
    
    
    def save_csv(self, columns=[&#34;x&#34;,&#34;y&#34;,&#34;z&#34;, &#34;pred&#34;, &#34;mask&#34;]):
        &#34;&#34;&#34;Save predicted maps as csv file.&#34;&#34;&#34;
        
        pred_gdf_export = self.pred_gdf[columns]
        pred_gdf_export.to_csv(os.path.join(self.save_figures_path, self.uid+&#39;_&#39;+self.date+&#39;_3d.csv&#39;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="SM.maps.SpatialMap"><code class="flex name class">
<span>class <span class="ident">SpatialMap</span></span>
<span>(</span><span>name, method, date, csv_file=None, plot_sensor_locs=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatialMap(object):
    def __init__(self, name, method, date, csv_file=None, plot_sensor_locs=True):

        self.name = name
        self.method = method
        self.uid = self.name + &#39;_&#39; +self.method 
        self.csv_file = csv_file
        self.date = date
        self.save_models_path = os.path.join(Project.models_path, self.name, 
                                             self.method)
        self.save_figures_path = os.path.join(Project.figures_path, self.name, 
                                              self.method)
        self.save_results_path = os.path.join(Project.figures_path)
        self.pred_gdf = None
        self.plot_sensor_locs = plot_sensor_locs

        Path(self.save_models_path).mkdir(parents=True, exist_ok=True)
        Path(self.save_figures_path).mkdir(parents=True, exist_ok=True)

        if self.csv_file is not None:
            print(&#34;The specified csv file will be taken for map creation.&#34;)
            self._create_gdf_from_csv()
        else:
            if Project.project_type == &#34;SpatioTempModel&#34;:
                self._predict_spatiotempmodel()
            else:
                self._predict()

        if self.plot_sensor_locs == True:
            try:
                self.daily_gdf = read_data()
            except FileNotFoundError:
                self.plot_sensor_locs = False
                print(&#34;Found no files with sensor locations.&#34;)

                
    def plot_maps(self, grid = True):
        &#34;&#34;&#34;Plot predicted raster data as maps and save as PNG.
        
        Parameter
        ---------
        grid : boolean, Default: True
            Set to True to plot the raster grid lines.
        &#34;&#34;&#34;
        
        # to plot sensor locatoins, load training_test data
        if self.plot_sensor_locs == True:

            daily_gdf = self.daily_gdf
            
            if not isinstance(daily_gdf, gpd.GeoDataFrame):
                daily_gdf = create_gdf_from_df(
                        daily_gdf, x=&#34;UTMWGS84_E[m]&#34;, y=&#34;UTMWGS84_N[m]&#34;)              
        
            if &#34;Date&#34; in daily_gdf.columns:
                try:
                    # if model is of class SpatioTempModel
                    daily_gdf = daily_gdf[daily_gdf[&#39;Date&#39;] == self.date]
                except: 
                    # if model is of class TrainDailyModel
                    daily_gdf = daily_gdf[daily_gdf[&#39;Date&#39;]==pd.to_datetime(self.date)]
        
        # load predicted raster data
        pred_gdf = self.pred_gdf
        if not isinstance(pred_gdf, gpd.GeoDataFrame):
            pred_gdf = create_gdf_from_df(pred_gdf)
        
        # check depth levels to create plot grid
        depth_list = pred_gdf[&#39;z&#39;].unique()
        n_depth = len(depth_list)

        # create plot grid and set color scheme
        fig, axes = plt.subplots(1, n_depth, figsize=(3*n_depth,6), sharey = True, sharex = True)
        #cmap = &#39;cviridis_r&#39;
        cmap = mpl.cm.get_cmap(&#39;cividis&#39;)
        cmap = cmap.reversed()
        norm = mpl.colors.Normalize(vmin = 0.1, vmax = 0.35)
        cmap.set_under(&#34;white&#34;)
        cmap.set_over(&#34;black&#34;)
        fmt = lambda x, pos: &#39;{:.0f}&#39;.format(x)

        # plot depth specific maps
        for i in range(n_depth):
    
            gdf_d = pred_gdf[pred_gdf[&#39;z&#39;]==depth_list[i]]
            
            gdf_d_plot = gdf_d.plot(ax=axes[i], column = &#39;pred&#39;, cmap = cmap, norm = norm)
            if self.plot_sensor_locs == True:
                daily_gdf_d = daily_gdf[daily_gdf[&#39;Depth_m&#39;] == depth_list[i]]
                daily_gdf_d.plot(ax=axes[i], column = &#39;Soil_moisture&#39;, cmap = cmap, norm = norm, edgecolor = &#39;k&#39;)
    
            axes[i].yaxis.set_major_formatter(mpl.ticker.FuncFormatter(fmt))
            axes[i].xaxis.set_major_formatter(mpl.ticker.FuncFormatter(fmt))
            axes[i].set_title(&#34;Depth [m]: &#34; + str(depth_list[i]), pad=20)
            if grid == True:
                axes[i].grid(color = &#39;grey&#39;, linestyle = &#39;--&#39;)
            collection = gdf_d_plot.collections[0]
        
        cbar = plt.colorbar(collection, ax=axes[-1], extend=&#39;both&#39;)
        cbar.ax.set_ylabel(&#39;Soil moisture [-]&#39;, fontsize = 14)
        
        # save maps as png
        f_path = os.path.join(self.save_figures_path, self.uid+&#39;_&#39;+self.date+&#39;_3d.png&#39;)
        plt.savefig(f_path)

        
    def _find_date_model_fname(self, date, model_path):
        
        list_files = os.listdir(model_path)

        file_name = None

        for each_file in list_files:
            if fnmatch.fnmatch(each_file, &#39;*_&#39;+date+&#39;*_model.sav&#39;):
                file_name = each_file.split(&#39;.&#39;)[0][:-6]

        if file_name == None:
            raise FileNotFoundError(&#34;There is no saved model with the specified name. \nTrain a model first or specify a csv file.&#34;)
        date = file_name.split(&#39;_&#39;)[2]

        return date, file_name
    

    def _predict(self):

        raster_data = read_raster()
        raster_data = raster_data[raster_data[&#39;mask&#39;]==False]
        processed_raster_data = preprocess_raster(raster_data)

        date, fname =self._find_date_model_fname(self.date, self.save_models_path)
        
        fpath = os.path.join(self.save_models_path, fname)
        
        model, scaler = load_model(fpath)
        
        data_scaled = scaler.transform(processed_raster_data.values)

        sm_pred = model.predict(data_scaled)

        raster_data[&#39;pred&#39;] = sm_pred 

        raster_data= raster_data.rename(columns = {&#39;z&#39;:&#39;Depth_m&#39;})
       
        self.pred_gdf = raster_data
        #self.date = date


        #return self.date, self.pred_gdf
        return self.pred_gdf
    
    
    def _predict_spatiotempmodel(self):
        &#34;&#34;&#34;Predict a map for a specific time stamp for a model of class 
        SpatioTempModel.
        
        Returns
        -------
        pandas.DataFrame
            Spatial map, columns (&#34;x&#34;, &#34;y&#34;, &#34;z&#34;, &#34;mask&#34;, &#34;pred&#34;).
        &#34;&#34;&#34;
        # load and preprocess raster data
        raster_data = read_raster()
        raster_data = raster_data[raster_data[&#39;mask&#39;]==False]
        processed_raster_data = preprocess_raster_spatiotempmodel(raster_data)
        feature_selected_raster_data = raster_select_features(
                                            processed_raster_data, self.date)
        # load regression model
        fpath = os.path.join(self.save_models_path, self.uid)
        model, scaler = load_model(fpath)
        
        # scale, predict
        data_scaled = scaler.transform(feature_selected_raster_data.values)
        sm_pred = model.predict(data_scaled)
        
        # output 
        pred_raster = processed_raster_data[[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;mask&#39;]]
        pred_raster = pred_raster.assign(pred = sm_pred) 
        self.pred_gdf = pred_raster
        
        # self.pred_gdf should look like this
        #            x           y     z     mask      pred
        #0      641952.55  5724795.24  0.05  False  0.229296
        return self.pred_gdf


    def _create_gdf_from_csv(self):

        df = pd.read_csv(self.csv_file)
        df = df[df[&#39;mask&#39;]==False]

        self.pred_gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy(df.x, df.y))
        
        return self.pred_gdf
    
    
    
    def save_csv(self, columns=[&#34;x&#34;,&#34;y&#34;,&#34;z&#34;, &#34;pred&#34;, &#34;mask&#34;]):
        &#34;&#34;&#34;Save predicted maps as csv file.&#34;&#34;&#34;
        
        pred_gdf_export = self.pred_gdf[columns]
        pred_gdf_export.to_csv(os.path.join(self.save_figures_path, self.uid+&#39;_&#39;+self.date+&#39;_3d.csv&#39;))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="SM.maps.SpatialMap.plot_maps"><code class="name flex">
<span>def <span class="ident">plot_maps</span></span>(<span>self, grid=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot predicted raster data as maps and save as PNG.</p>
<h2 id="parameter">Parameter</h2>
<p>grid : boolean, Default: True
Set to True to plot the raster grid lines.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_maps(self, grid = True):
    &#34;&#34;&#34;Plot predicted raster data as maps and save as PNG.
    
    Parameter
    ---------
    grid : boolean, Default: True
        Set to True to plot the raster grid lines.
    &#34;&#34;&#34;
    
    # to plot sensor locatoins, load training_test data
    if self.plot_sensor_locs == True:

        daily_gdf = self.daily_gdf
        
        if not isinstance(daily_gdf, gpd.GeoDataFrame):
            daily_gdf = create_gdf_from_df(
                    daily_gdf, x=&#34;UTMWGS84_E[m]&#34;, y=&#34;UTMWGS84_N[m]&#34;)              
    
        if &#34;Date&#34; in daily_gdf.columns:
            try:
                # if model is of class SpatioTempModel
                daily_gdf = daily_gdf[daily_gdf[&#39;Date&#39;] == self.date]
            except: 
                # if model is of class TrainDailyModel
                daily_gdf = daily_gdf[daily_gdf[&#39;Date&#39;]==pd.to_datetime(self.date)]
    
    # load predicted raster data
    pred_gdf = self.pred_gdf
    if not isinstance(pred_gdf, gpd.GeoDataFrame):
        pred_gdf = create_gdf_from_df(pred_gdf)
    
    # check depth levels to create plot grid
    depth_list = pred_gdf[&#39;z&#39;].unique()
    n_depth = len(depth_list)

    # create plot grid and set color scheme
    fig, axes = plt.subplots(1, n_depth, figsize=(3*n_depth,6), sharey = True, sharex = True)
    #cmap = &#39;cviridis_r&#39;
    cmap = mpl.cm.get_cmap(&#39;cividis&#39;)
    cmap = cmap.reversed()
    norm = mpl.colors.Normalize(vmin = 0.1, vmax = 0.35)
    cmap.set_under(&#34;white&#34;)
    cmap.set_over(&#34;black&#34;)
    fmt = lambda x, pos: &#39;{:.0f}&#39;.format(x)

    # plot depth specific maps
    for i in range(n_depth):

        gdf_d = pred_gdf[pred_gdf[&#39;z&#39;]==depth_list[i]]
        
        gdf_d_plot = gdf_d.plot(ax=axes[i], column = &#39;pred&#39;, cmap = cmap, norm = norm)
        if self.plot_sensor_locs == True:
            daily_gdf_d = daily_gdf[daily_gdf[&#39;Depth_m&#39;] == depth_list[i]]
            daily_gdf_d.plot(ax=axes[i], column = &#39;Soil_moisture&#39;, cmap = cmap, norm = norm, edgecolor = &#39;k&#39;)

        axes[i].yaxis.set_major_formatter(mpl.ticker.FuncFormatter(fmt))
        axes[i].xaxis.set_major_formatter(mpl.ticker.FuncFormatter(fmt))
        axes[i].set_title(&#34;Depth [m]: &#34; + str(depth_list[i]), pad=20)
        if grid == True:
            axes[i].grid(color = &#39;grey&#39;, linestyle = &#39;--&#39;)
        collection = gdf_d_plot.collections[0]
    
    cbar = plt.colorbar(collection, ax=axes[-1], extend=&#39;both&#39;)
    cbar.ax.set_ylabel(&#39;Soil moisture [-]&#39;, fontsize = 14)
    
    # save maps as png
    f_path = os.path.join(self.save_figures_path, self.uid+&#39;_&#39;+self.date+&#39;_3d.png&#39;)
    plt.savefig(f_path)</code></pre>
</details>
</dd>
<dt id="SM.maps.SpatialMap.save_csv"><code class="name flex">
<span>def <span class="ident">save_csv</span></span>(<span>self, columns=['x', 'y', 'z', 'pred', 'mask'])</span>
</code></dt>
<dd>
<div class="desc"><p>Save predicted maps as csv file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_csv(self, columns=[&#34;x&#34;,&#34;y&#34;,&#34;z&#34;, &#34;pred&#34;, &#34;mask&#34;]):
    &#34;&#34;&#34;Save predicted maps as csv file.&#34;&#34;&#34;
    
    pred_gdf_export = self.pred_gdf[columns]
    pred_gdf_export.to_csv(os.path.join(self.save_figures_path, self.uid+&#39;_&#39;+self.date+&#39;_3d.csv&#39;))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="SM" href="index.html">SM</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="SM.maps.SpatialMap" href="#SM.maps.SpatialMap">SpatialMap</a></code></h4>
<ul class="">
<li><code><a title="SM.maps.SpatialMap.plot_maps" href="#SM.maps.SpatialMap.plot_maps">plot_maps</a></code></li>
<li><code><a title="SM.maps.SpatialMap.save_csv" href="#SM.maps.SpatialMap.save_csv">save_csv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>